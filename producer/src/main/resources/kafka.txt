1.启动一个consumer时默认只从最新的消息偏移量(offset)接收消息，如果想从头开始消费需要设置from beginning
2.topic的消息都存在kafka-logs/主题-分区0/00000000.log。一个topic可以创建多个分区，防止单文件存储消息量过大，可以提高读写并发能力
3.在kafka-logs目录下默认有50个_consumer_offset_49分区文件。目的是为了分布式系统中，不同消费者组同时可以向broker提交消息消费偏移量，
提交定位是根据hash(GroupId+topicName+partitionId)%50。这个文件里记录了某个消费者组消费某个topic的消息消费偏移量
4.在集群环境创建topic时除了指定partition个数外还可以指定副本数量。每个分区都会创建相应数量的副本放在不同的broker上。
每个分区消息数据的所有副本中会有一个leader,生产者向leader发送消息，leader负责向其他副本同步数据，消费者向leader消费消息。
如果某个leader下线，则会重新选举leader
5.单播消息：一个消费者组里多个消费者同时订阅一个topic,但一条消息只能被一个消费者消费
6.多播消息：不同消费者组里的消费者订阅同一个topic里的消息，但每个消费者组里还是只能有一个消费者可以消费当前消息
7.当前消费者group，当前topic，当前partition的current-offset:7当前消息偏移量，已经消费的消息数。log-end-offset:11总的消息数量。lag:4积压的消息量
8.消息默认会被保存7天，之后会被删除
9.同一个消费者组内可以启动的消费者数量与topic的partition数相同，多出来的也消费不到消息，因为一个partition内消息只能被同一个group内的一个消费者消费。
但可以作为冗余服务以防某个消费者下线，提高系统可用性，（疑问：同一个partition内的消息是被一个固定消费者消费吗）但一个group内的一个consumer可以消费多个partition
10.集群中同一个partition内的消息可以保证顺序性消费，因为一个partition内消息只能被一个group内的一个消费者消费。

11.同步发送消息：生产者消息发送后会阻塞等待一个ack确认信号，默认会等待3s,超过会重试，默认3次
    异步发送消息：生产者发送消息时传递一个回调函数，消费者返回ack时被调用
    关于ack可以配置0，1，-1/all。0代表不等broker里的partition将消息保存log文件就返回，
    1代表需要partition多副本中的leader将消息保存到log后才返回，-1/all可以设置等待多个副本都同步消息后才返回
12.因为有重试机制，怎么保证消息消费的幂等性
13.生产者可以设置消息缓冲区大小32mb和本地线程缓冲区大小16kb。消息不会立即被发送到broker,而是本地线一次从消息缓冲区拉取16kb的消息，如果不够16kb,linger.ms=10ms后也会发送给broker
14.consumer拉取消息后自动提交offset,如果消息还没有消费就挂了，那么将会丢失消息。也可以在处理消息时手动提交offset，分为同步提交和异步提交，等待broker返回ack。
疑问：手动提交ack时如果消息处理时间很长，又没有及时提交offset,同消费者组里的其他消费者还能拉取消息吗?
答：不会，因为consumer_offsets文件是由hash(GroupId+topicName+partitionId)%50计算分配的，
也就是说同一个group里的不同consumer不会访问同一个topic的同一个partition的offset信息，所以不会冲突，因为其他consumer会访问不同的patition
15.消费者每一秒向集群发送心跳，集群协调者超过10s没接收到心跳会触发rebalance机制
16.集群环境中topic的各个patition副本怎么选举leader。broker中谁来作为controller

消息顺序执行，防止消息丢失和重复消费，消息挤压，延时队列，事务